## 1、类的实例化顺序

```
比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，他们的执行顺序

先静态、先父后子。

先静态：父静态 > 子静态

优先级：父类 > 子类 静态代码块 > 非静态代码块 > 构造函数

    一个类的实例化过程：
    
    1、 父类中的static代码块，当前类的static
    
    2、 顺序执行父类的普通代码块
    
    3、 父类的构造函数
    
    4、 子类普通代码块
    
    5、 子类（当前类）的构造函数，按顺序执行。
    
    6、 子类方法的执行，
```

## 2、简述Java的对象结构

```
    Java对象由三个部分组成：对象头、实例数据、对齐填充。
    
    对象头由两部分组成:
        第一部分存储对象自身的运行时数据：哈希码、GC分代年龄、锁标识状态、线程持有的锁、偏向线程ID（一般占32/64 bit）。
        第二部分是指针类型，指向对象的类元数据类型（即对象代表哪个类）。如果是数组对象，则对象头中还有一部分用来记录数组长度。
    
    实例数据用来存储对象真正的有效信息（包括父类继承下来的和自己定义的）
    
    对齐填充：JVM要求对象起始地址必须是8字节的整数倍（8字节对齐 )
```

## 3、怎么获取 Java 程序使用的内存？堆使用的百分比？

```
    可以通过 java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。
    通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。
        Runtime.freeMemory() 方法返回剩余空间的字节数，
        Runtime.totalMemory()方法总内存的字节数，
        Runtime.maxMemory() 返回最大内存的字节数。
```

## 4、说一下 ArrayList 的优缺点

```
    ArrayList的优点如下：
    
        1、 ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，因此查找的时候非常快。
        
        2、 ArrayList 在顺序添加一个元素的时候非常方便。
    
    ArrayList 的缺点如下：
    
        1、 删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。
        
        2、 插入元素的时候，也需要做一次元素复制操作，缺点同上。
        
        3、 ArrayList 比较适合顺序添加、随机访问的场景。
```

## 5、Java中有几种类型的流

```
    字节流和字符流。
    字节流继承于InputStream、OutputStream，字符流继承于Reader、Writer。
    在" http://java.io "包中还有许多其他的流，主要是为了提高性能和使用方便。
    关于Java的I/O需要注意的有两点：
        一是两种对称性（输入和输出的对称性，字节和字符的对称性）；
        二是两种设计模式（适配器模式和装潢模式）。另外Java中的流不同于C#的是它只有一个维度一个方向。
```

## 6、如果你提交任务时，线程池队列已满，这时会发生什么

```
    有俩种可能：
    
    1、 如果使用的是无界队列 LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，
        因为 LinkedBlockingQueue 可以近乎认为是一个无穷大的队列，可以无限存放任务
    
    2、 如果使用的是有界队列比如 ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue 中，ArrayBlockingQueue 满了，
        会根据maximumPoolSize 的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue 继续满，
        那么则会使用拒绝策略RejectedExecutionHandler 处理满了的任务，默认是 AbortPolicy

```

## 7、Spring中自动装配的方式有哪些？

```
    1、 no：不进行自动装配，手动设置Bean的依赖关系。
    
    2、 byName：根据Bean的名字进行自动装配。
    
    3、 byType：根据Bean的类型进行自动装配。
```

## 8、如何调用 wait() 方法的？使用 if 块还是循环？为什么？

```
    处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。
    
    wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，
    所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码：
    
    synchronized (monitor) { 
        // 判断条件谓词是否得到满足 
        while(!locked) { 
            // 等待唤醒 monitor.wait(); 
        } 
        // 处理其他的业务逻辑 
    }

```

## 8、聚集索引与非聚集索引有什么区别？

```
    所有的索引都是为了更快地检索数据，索引存放在索引页中，数据存放在数据页中，索引以B（balance）树的形式存储
    
    聚集索引：聚集索引用于决定数据表中的物理存储顺序，一张表最多有一个聚集索引。
        聚集索引的字段值尽量不能修改，因为修改后，因为修改后数据表的物理顺序需要重写排序。通常主键就是聚集索引
    
    非聚集索引：非聚集索引的关键自是index，不会决定表的物理存储顺序，在一张表内最多可以有249个非聚集索引。
```