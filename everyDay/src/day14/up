1. notify()和 notifyAll()有什么区别？
    -- 唤醒一个或者唤醒所有等待线程池中的线程

2. 线程的 run()和 start()有什么区别？
    -- 每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。

3. 线程池中 submit()和 execute()方法有什么区别？
    -- 接收的参数不一样

        submit有返回值，而execute没有

        submit方便Exception处理
4. 在 java 程序中怎么保证多线程的运行安全？
    -- 原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；

       可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；

       有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。

5. 多线程锁的升级原理是什么？
    -- 在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。

6. 什么是死锁？
    -- 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。
    此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系统层面的一个错误，是进程死锁的简称，
    最早在 1965 年由 Dijkstra 在研究银行家算法时提出的，它是计算机操作系统乃至整个并发程序设计领域最难处理的问题之一。

7. 怎么防止死锁？
    -- 死锁的四个必要条件：

       互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源

       请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放

       不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放

       环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系

8. ThreadLocal 是什么？有哪些使用场景？
    -- 线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。
    Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，
    在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。

9. 说一下 synchronized 底层实现原理？
    -- synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。

       Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：

       普通同步方法，锁是当前实例对象

       静态同步方法，锁是当前类的class对象

       同步方法块，锁是括号里面的对象

10. synchronized 和 volatile 的区别是什么？
    -- volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。

       volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。

       volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。

       volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。

       volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。

11. synchronized 和 Lock 有什么区别？
    -- 首先synchronized是java内置关键字，在jvm层面，Lock是个java类；

       synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；

       synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；

       用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；

       synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；

       Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。

12. synchronized 和 ReentrantLock 区别是什么？
    -- synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：

       ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁

       ReentrantLock可以获取各种锁的信息

       ReentrantLock可以灵活地实现多路通知

       另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word。